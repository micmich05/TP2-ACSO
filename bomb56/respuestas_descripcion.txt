mail: mmichanie@udesa.edu.ar
nombre: Micol Michanie

Fase 1
En esta fase la bomba recibe un string y lo compara con un string esperado usando strings_not_equal. Se  carga en el registro rsi la dirección calculada como rip+0xc7c62.
En caso de que sean distintos, la bomba explota. En caso contrario, no explota. Se accedio al registro 
rsi usando  x/s  para obtener el string esperado con un breakpoint en strings_not_equal.

Respuesta: Junta esperencia en la vida  Porque nada ensenha tanto Como el sufrir y el llorar

Fase 2
Se recibe un string con dos números enteros: primer_numero_ingresado y segundo_numero_ingresado. La logica principal de la clase de da cuando llama a una funcion misterio que ejecuta una serie de operaciones aritmeticas sobre los parametros de entrada. Básicamente las condiciones que tienen que cumplirse para que la bomba no explote son:
    a - Haber exactamente 11 bits -guarda 0xa en edx- en primer_numero_ingresado
    b - primer_numero_ingresado XOR segundo_numero_ingresado < 0 (bit mas significativo en 1)
Si ambas caracteristicas se cumplen, se pasa la fase 2. Sino, explota.
Una solucion sencilla es: 2047 (11 unos exactamente) y 2147485695 (en ese orden). En particular, 
11111111111 XOR 10000000000000000000011111111111 = 10000000000000000000000000000000 (bit más significativo en 1, negativo). Los parametros que recibe la funcion misterio son en los registros 

Respuesta: 2047 2147485695

Fase 3:
Se reciben un string y un numero entero. La fase llama a la funcion cuenta, que accede al archivo palabras.txt (que esta ordenado alfabeticamente)
y hace una busqueda binaria sobre este. El target de la busqueda es el string pasado por parametro. La funcion tiene una cantidad de iteraciones (counter), tienen que ser menos de 11
si se pasa de ese valor (no encontro todavia la palabra), explota. Si termina la busqueda, se fija si se hicieron mas de 6 iteraciones. Sino, explota. 
Si pasa todo lo anterior, se fija si el numero entero pasado como parametro es igual a la cantidad de iteraciones que realizo, sino explota.
Si todo esto se cumple, se pasa la fase 3. Para obtener una solucion valida, se corrio un scrypt de python que simulaba la busqueda binaria e imprimia las soluciones.
La elegida fue forrear 10. La funcion que genera las soluciones es soluciones_validas en phase_3_aux.

Respuesta: forrear 10

Fase 4:
Se reciben dos numeros enteros y se ejecuta la fase. La lógica es la siguiente:
Arranca por un número i (primer entero pasado), representando el índice del número en un arreglo, indexa el arreglo de la forma arreglo[i],
y usa ese número como nuevo índice. Continúa con esto hasta hacer exactamente 6 pasos, esperando llegar finalmente a i = 15. Además, a medida que recorre los 
índices va acumulando la suma de los números que ve. Si no llega al 15 en exactamente 6 pasos o no se pasa la suma total correctamente, explota.

Para resolver la fase, se accedio al arreglo en memoria: [7, 4, 6, 8, 13, 10, 15, 9, 0, 12, 3, 5, 2, 11, 1, 14]
Como quiero llegar al 15 en exactamente 6 pasos:

Si quiero 15 --> necesito llegar al 6 (indice en el arreglo)
Si quiero un 6 --> 2
Si quiero un 2 -–> 12
Si quiero un 12 --> 9
Si quiero un 9 --> 7
Si quiero un 7 --> paso 0

suma final = 7 + 9 + 12 + 2 + 6 + 15

Por lo tanto, la solucion es:  0 (índice) 51 (suma final)

Respuesta: 0 51



